import { احصل, التالي, السابق, تحقق, تطابق } from "./TokenUtils.js";
import { المحللات } from "../AlifParser.js";
import { محلل_العمليات } from "./Statements/AlifOperations.js";

export function محلل_التعبير(الرموز) {
    if (!الرموز || !Array.isArray(الرموز)) {
        throw new Error(
            'الرموز غير معرفة أو غير صحيحة "محلل التعبير"' + الرموز
        );
    }

    const الرمز = احصل(الرموز);

    // دعم امر داخل امر
    if (تحقق(الرموز, "كلمة")) {
        const الامر = احصل(الرموز)?.القيمة;
        if (المحللات[الامر]) return المحللات[الامر](الرموز, الامر);
    }

    // دعم التعابير: المعرف مع دعم الفهرس المربع
    if (تحقق(الرموز, "معرف")) {
        // دعم العمليات الحسابية
        التالي(الرموز);
        if (تحقق(الرموز, "رمز_حسابي")) {
            السابق(الرموز);
            return محلل_العمليات(الرموز);
        } else {
            السابق(الرموز);
            const identToken = تطابق(الرموز, "معرف");
            let node = { نوع: "معرف", اسم: identToken.القيمة, رمز: identToken };
            // دعم الفهرس بواسطة اقواس مربعة
            while (تحقق(الرموز, "اقواس", "[")) {
                تطابق(الرموز, "اقواس", "[");
                // تخطي المسافات والأسطر الفارغة
                while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد"))
                    التالي(الرموز);
                const indexExpr = محلل_التعبير(الرموز);
                تطابق(الرموز, "اقواس", "]");
                node = { نوع: "فهرس_عنصر", list: node, index: indexExpr };
            }
            return node;
        }
    }

    // لا يغير في الارقام والنصوص
    if (تحقق(الرموز, "رقم") || تحقق(الرموز, "نص")) {
        // دعم العمليات الحسابية
        التالي(الرموز);
        if (تحقق(الرموز, "رمز_حسابي")) {
            السابق(الرموز);
            return محلل_العمليات(الرموز);
        } else {
            السابق(الرموز);
            let القيمة = احصل(الرموز)?.القيمة;
            if (القيمة.startsWith('م"')) {
                const النص = القيمة;
                const محتوى = النص.slice(2, -1);
                const بعد_التحويل = محتوى.replace(/{([^}]+)}/g, "${$1}");
                القيمة = "`" + بعد_التحويل + "`";
            }
            const token = التالي(الرموز);
            return { نوع: "قيمة", قيمة: القيمة, رمز: token };
        }
    }

    const قيم = {
        صح: { نوع: "صح", قيمة: true },
        خطأ: { نوع: "خطأ", قيمة: false },
        خطا: { نوع: "خطأ", قيمة: false },
        عدم: { نوع: "عدم", قيمة: null },
    };
    if (تحقق(الرموز, "كلمة") && قيم[الرمز.القيمة]) {
        التالي(الرموز);
        return قيم[الرمز.القيمة];
    }

    // دعم القيم داخل اقواس مثلا: (5, 7, صح, "اهلا")
    if (تحقق(الرموز, "اقواس", "(")) {
        التالي(الرموز);
        التالي(الرموز);
        if (تحقق(الرموز, "فاصلة")) {
            السابق(الرموز);
            const قيم = [];
            while (!تحقق(الرموز, "اقواس", ")")) {
                // تخطي المسافات والاسطر الفارغة
                while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد"))
                    التالي(الرموز);

                const القيمة = محلل_التعبير(الرموز);
                if (!القيمة) {
                    const error = new Error(
                        `خطأ في تحليل القيمة داخل الأقواس الدائرية`
                    );
                    error.line = `في السطر ` + احصل(الرموز)?.السطر;
                    throw error;
                }
                قيم.push(القيمة);
                // اذا لا يوجد فاصلة توقف
                if (تحقق(الرموز, "فاصلة")) التالي(الرموز);
            }
            تطابق(الرموز, "اقواس", ")");
            return { نوع: "قائمة_اقواس", قيم };
        } else {
            السابق(الرموز);
            السابق(الرموز);
            return محلل_العمليات(الرموز);
        }
    }

    // دعم القيم داخل اقواس مربعة مثلا: [5, 7, صح, "اهلا"]
    if (تحقق(الرموز, "اقواس", "[")) {
        التالي(الرموز);
        const قيم = [];
        while (!تحقق(الرموز, "اقواس", "]")) {
            // تخطي المسافات والاسطر الفارغة
            while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد"))
                التالي(الرموز);

            const القيمة = محلل_التعبير(الرموز);
            if (!القيمة) {
                const error = new Error(
                    `خطأ في تحليل القيمة داخل الأقواس المربعة`
                );
                error.line = `في السطر ` + احصل(الرموز)?.السطر;
                throw error;
            }
            قيم.push(القيمة);
            // اذا لا يوجد فاصلة توقف
            if (تحقق(الرموز, "فاصلة")) التالي(الرموز);
        }
        تطابق(الرموز, "اقواس", "]");
        return { نوع: "قائمة", قيم };
    }
    // دعم القيم داخل اقواس متعرجة مثلا: {5, 7, صح, "اهلا"}
    if (تحقق(الرموز, "اقواس", "{")) {
        التالي(الرموز);
        const خصائص = [];
        while (!تحقق(الرموز, "اقواس", "}")) {
            // تخطي المسافات والاسطر الفارغة
            while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد"))
                التالي(الرموز);

            let المفتاح;
            if (تحقق(الرموز, "نص")) {
                const رمز_المفتاح = تطابق(الرموز, "نص");
                المفتاح = رمز_المفتاح.القيمة.slice(1, -1);
            } else if (تحقق(الرموز, "معرف")) {
                const رمز_المفتاح = تطابق(الرموز, "معرف");
                المفتاح = رمز_المفتاح.القيمة;
            } else {
                const error = new Error(`توقع مفتاح في فهرس قبل ":"`);
                error.line = `في السطر ` + احصل(الرموز)?.السطر;
                throw error;
            }
            تطابق(الرموز, "رمز_حسابي", ":");
            const القيمة = محلل_التعبير(الرموز);
            if (!القيمة) {
                const error = new Error(
                    `خطأ في تحليل القيمة داخل الأقواس المتعرجة`
                );
                error.line = `في السطر ` + احصل(الرموز)?.السطر;
                throw error;
            }
            خصائص.push({ المفتاح, القيمة });
            // اذا لا يوجد فاصلة توقف
            if (تحقق(الرموز, "فاصلة")) التالي(الرموز);
        }

        تطابق(الرموز, "اقواس", "}");
        return { نوع: "فهرس", خصائص };
    }

    console.warn(`تحذير: "${الرمز.القيمة}" غير مفهوم في السطر ` + الرمز.السطر);
    return "نوع غير معروف";
}
