import { احصل, التالي, السابق, تحقق, تطابق } from "./TokenUtils.js";
import { المحللات } from "../AlifParser.js";
import { محلل_العمليات } from "./Statements/AlifOperations.js";

export function محلل_التعبير(الرموز) {
    if (!الرموز || !Array.isArray(الرموز)) {
        throw new Error(
            'الرموز غير معرفة أو غير صحيحة "محلل التعبير"' + الرموز
        );
    }

    const الرمز = احصل(الرموز);

    // دعم العمليات الحسابية
    if (
        تحقق(الرموز, "رقم") ||
        تحقق(الرموز, "رمز_حسابي") ||
        تحقق(الرموز, "معرف")
    ) {
        try {
            return محلل_العمليات(الرموز);
        } catch (e) {
            السابق(الرموز);
            if (تحقق(الرموز, "رقم")) {
                let القيمة = احصل(الرموز)?.القيمة;
                const token = التالي(الرموز);
                return { نوع: "قيمة", قيمة: القيمة, رمز: token };
            }
        }
    }

    // دعم التعابير: المعرف مع دعم الفهرس المربع
    if (تحقق(الرموز, "معرف")) {
        const identToken = تطابق(الرموز, "معرف");
        let node = { نوع: "معرف", اسم: identToken.القيمة, رمز: identToken };
        // دعم الفهرس بواسطة اقواس مربعة
        while (تحقق(الرموز, "اقواس", "[")) {
            تطابق(الرموز, "اقواس", "[");
            // تخطي المسافات والأسطر الفارغة
            while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد"))
                التالي(الرموز);
            const indexExpr = محلل_التعبير(الرموز);
            تطابق(الرموز, "اقواس", "]");
            node = { نوع: "فهرس_عنصر", list: node, index: indexExpr };
        }
        return node;
    }

    // لا يغير في الارقام والنصوص
    if (تحقق(الرموز, "رقم") || تحقق(الرموز, "نص")) {
        let القيمة = احصل(الرموز)?.القيمة;
        if (القيمة.startsWith('م"')) {
            const النص = القيمة;
            const محتوى = النص.slice(2, -1);
            const بعد_التحويل = محتوى.replace(/{([^}]+)}/g, "${$1}");
            القيمة = "`" + بعد_التحويل + "`";
        }
        const token = التالي(الرموز);
        return { نوع: "قيمة", قيمة: القيمة, رمز: token };
    }

    const قيم = {
        صح: { نوع: "صح", قيمة: true },
        خطأ: { نوع: "خطأ", قيمة: false },
        خطا: { نوع: "خطأ", قيمة: false },
        عدم: { نوع: "عدم", قيمة: null },
        أو: { نوع: "أو", قيمة: "||" },
        او: { نوع: "أو", قيمة: "||" },
        و: { نوع: "و", قيمة: "&&" },
    };
    if (تحقق(الرموز, "كلمة") && قيم[الرمز.القيمة]) {
        التالي(الرموز);
        return قيم[الرمز.القيمة];
    }

    // دعم امر داخل امر
    if (تحقق(الرموز, "كلمة")) {
        const الامر = احصل(الرموز)?.القيمة;
        if (المحللات[الامر]) return المحللات[الامر](الرموز, الامر);
    }

    // دعم القيم داخل اقواس مثلا: (5, 7, صح, "اهلا")
    if (تحقق(الرموز, "اقواس", "(")) {
        التالي(الرموز);
        const قيم = [];
        while (!تحقق(الرموز, "اقواس", ")")) {
            // تخطي المسافات والاسطر الفارغة
            while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد"))
                التالي(الرموز);

            const القيمة = محلل_التعبير(الرموز);
            if (!القيمة) {
                const error = new Error(
                    `خطأ في تحليل القيمة داخل الأقواس الدائرية`
                );
                error.line = `في السطر ` + احصل(الرموز)?.السطر;
                throw error;
            }
            قيم.push(القيمة);
            // اذا لا يوجد فاصلة توقف
            if (تحقق(الرموز, "فاصلة")) التالي(الرموز);
        }
        تطابق(الرموز, "اقواس", ")");
        return { نوع: "قائمة_اقواس", قيم };
    }
    // دعم القيم داخل اقواس مربعة مثلا: [5, 7, صح, "اهلا"]
    if (تحقق(الرموز, "اقواس", "[")) {
        التالي(الرموز);
        const قيم = [];
        while (!تحقق(الرموز, "اقواس", "]")) {
            // تخطي المسافات والاسطر الفارغة
            while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد"))
                التالي(الرموز);

            const القيمة = محلل_التعبير(الرموز);
            if (!القيمة) {
                const error = new Error(
                    `خطأ في تحليل القيمة داخل الأقواس المربعة`
                );
                error.line = `في السطر ` + احصل(الرموز)?.السطر;
                throw error;
            }
            قيم.push(القيمة);
            // اذا لا يوجد فاصلة توقف
            if (تحقق(الرموز, "فاصلة")) التالي(الرموز);
        }
        تطابق(الرموز, "اقواس", "]");
        return { نوع: "قائمة", قيم };
    }
    // دعم القيم داخل اقواس متعرجة مثلا: {5, 7, صح, "اهلا"}
    if (تحقق(الرموز, "اقواس", "{")) {
        التالي(الرموز);
        const خصائص = [];
        while (!تحقق(الرموز, "اقواس", "}")) {
            // تخطي المسافات والاسطر الفارغة
            while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد"))
                التالي(الرموز);

            let المفتاح;
            if (تحقق(الرموز, "نص")) {
                const رمز_المفتاح = تطابق(الرموز, "نص");
                المفتاح = رمز_المفتاح.القيمة.slice(1, -1);
            } else if (تحقق(الرموز, "معرف")) {
                const رمز_المفتاح = تطابق(الرموز, "معرف");
                المفتاح = رمز_المفتاح.القيمة;
            } else {
                const error = new Error(`توقع مفتاح في فهرس قبل ":"`);
                error.line = `في السطر ` + احصل(الرموز)?.السطر;
                throw error;
            }
            تطابق(الرموز, "رمز_حسابي", ":");
            const القيمة = محلل_التعبير(الرموز);
            if (!القيمة) {
                const error = new Error(
                    `خطأ في تحليل القيمة داخل الأقواس المتعرجة`
                );
                error.line = `في السطر ` + احصل(الرموز)?.السطر;
                throw error;
            }
            خصائص.push({ المفتاح, القيمة });
            // اذا لا يوجد فاصلة توقف
            if (تحقق(الرموز, "فاصلة")) التالي(الرموز);
        }

        تطابق(الرموز, "اقواس", "}");
        return { نوع: "فهرس", خصائص };
    }

    console.warn(`تحذير: تعبير غير مفهوم في السطر ` + الرمز.السطر);
}
