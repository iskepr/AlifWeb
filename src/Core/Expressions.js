import {
    إعادة_تعيين_المؤشر,
    احصل,
    التالي,
    السابق,
    المؤشر,
    تحقق,
    تطابق,
} from "./TokenUtils.js";
import { المحللات, محلل_الجملة } from "../AlifParser.js";
import { محلل_العمليات } from "./Statements/AlifOperations.js";
import { محلل_عام_للاقواس_يسبقها_نقطة } from "./Statements/AlifGeneral.js";
import { محلل_إستدعاء_دالة } from "./Statements/AlifFunction.js";
import { رمي_خطأ } from "./AlifErrors.js";
import { محلل_المصفوفة } from "./Statements/AlifList.js";
import { محلل_الفهرس } from "./Statements/AlifObject.js";
import { محلل_مترابطة } from "./Statements/AlifTuple.js";
import { تحليل_الشفرة } from "../AlifLexer.js";
import { إنشاء_الشفرة } from "../AlifGenerator.js";

export function محلل_التعبير(الرموز) {
    if (!الرموز || !Array.isArray(الرموز)) {
        throw new Error(
            'الرموز غير معرفة أو غير صحيحة "محلل التعبير"' + الرموز
        );
    }

    const الرمز = احصل(الرموز);

    // دعم امر داخل امر
    if (تحقق(الرموز, "كلمة")) {
        const الامر = احصل(الرموز)?.القيمة;
        if (المحللات[الامر]) return المحللات[الامر](الرموز, الامر);
    }

    // دعم التعابير: المعرف مع دعم الفهرس المربع
    if (تحقق(الرموز, "معرف")) {
        const المعرف = احصل(الرموز)?.القيمة;

        // دعم العمليات الحسابية
        التالي(الرموز);
        if (تحقق(الرموز, "رمز_حسابي")) {
            السابق(الرموز);
            return محلل_العمليات(الرموز);
        } else if (تحقق(الرموز, "اقواس", "(")) {
            السابق(الرموز);
            return محلل_إستدعاء_دالة(الرموز);
        } else if (تحقق(الرموز, "نقطة")) {
            التالي(الرموز);
            const الكلمة = محلل_التعبير(الرموز);

            if (
                الكلمة.المتغير == "مفاتيح" ||
                الكلمة.المتغير == "اضف" ||
                الكلمة.المتغير == "امسح" ||
                الكلمة.المتغير == "ادرج"
            ) {
                if (الكلمة.المتغير != "مفاتيح") السابق(الرموز);
                السابق(الرموز);
                السابق(الرموز);
                السابق(الرموز);
                return محلل_عام_للاقواس_يسبقها_نقطة(
                    الرموز,
                    المعرف,
                    الكلمة.المتغير
                );
            }

            return { نوع: "معرف_صنف", أسماء_صنف: [المعرف, الكلمة] };
        } else {
            السابق(الرموز);
            const البداية = المؤشر;
            const identToken = تطابق(الرموز, "معرف");
            let node = { نوع: "معرف", اسم: identToken.القيمة, رمز: identToken };
            // دعم س[5]
            if (تطابق(الرموز, "اقواس", "[")) {
                // تخطي المسافات والأسطر الفارغة
                while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد"))
                    التالي(الرموز);

                const indexExpr = محلل_التعبير(الرموز);
                تطابق(الرموز, "اقواس", "]");
                node = { نوع: "فهرس_عنصر", list: node, index: indexExpr };

                if (تحقق(الرموز, "رمز_حسابي")) {
                    const الحالي = المؤشر;
                    for (let i = 0; i < الحالي - البداية; i++) {
                        السابق(الرموز);
                    }
                    return محلل_العمليات(الرموز);
                }
            }
            return node;
        }
    }

    // لا يغير في الارقام والنصوص
    if (تحقق(الرموز, "رقم") || تحقق(الرموز, "نص")) {
        // دعم العمليات الحسابية
        التالي(الرموز);
        if (تحقق(الرموز, "رمز_حسابي")) {
            السابق(الرموز);
            return محلل_العمليات(الرموز);
        } else {
            السابق(الرموز);
            let القيمة = احصل(الرموز)?.القيمة;
            // التعامل مع القيم داخل النص المنسق م" {} "
            if (القيمة.startsWith('م"')) {
                const النص = القيمة;
                const محتوى = النص.slice(2, -1);
                const بعد_التحويل = محتوى.replace(
                    /{([^}]+)}/g,
                    (match, الشفرة) => {
                        const رموز = تحليل_الشفرة(الشفرة);

                        const الحالي = المؤشر;
                        إعادة_تعيين_المؤشر();

                        const ast = محلل_التعبير(رموز);
                        for (let i = 0; i < الحالي - رموز.length; i++) {
                            التالي(الرموز);
                        }
                        return "${" + إنشاء_الشفرة(ast) + "}";
                    }
                );
                القيمة = "`" + بعد_التحويل + "`";
            }
            const token = التالي(الرموز);
            return { نوع: "قيمة", قيمة: القيمة, رمز: token };
        }
    }

    if (تحقق(الرموز, "رمز_حسابي")) return محلل_العمليات(الرموز);
    // تخطي المسافات والاسطر الفارغة
    if (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد")) التالي(الرموز);

    // دعم القيم داخل مترابطة مثلا: (5, 7, صح, "اهلا")
    if (تحقق(الرموز, "اقواس", "(")) {
        التالي(الرموز);
        التالي(الرموز);
        if (تحقق(الرموز, "فاصلة")) {
            const قيم = محلل_مترابطة(الرموز);
            return { نوع: "مترابطة", قيم };
        } else {
            السابق(الرموز);
            السابق(الرموز);
            return محلل_العمليات(الرموز);
        }
    }

    // دعم القيم داخل اقواس مربعة مثلا: [5, 7, صح, "اهلا"]
    if (تحقق(الرموز, "اقواس", "[")) {
        const قيم = محلل_المصفوفة(الرموز);
        return { نوع: "قائمة", قيم };
    }

    // دعم القيم داخل اقواس متعرجة مثلا: {5, 7, صح, "اهلا"}
    if (تحقق(الرموز, "اقواس", "{")) {
        const خصائص = محلل_الفهرس(الرموز);
        return { نوع: "فهرس", خصائص };
    }

    if (!الرمز?.النوع == "مسافة")
        console.warn(
            `تحذير: "${الرمز?.القيمة}" غير مفهوم في السطر ` + الرمز?.السطر
        );
    return false;
}
