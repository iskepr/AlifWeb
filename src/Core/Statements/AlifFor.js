import { احصل, التالي, تحقق, تطابق } from "../TokenUtils.js";
import { محلل_التعبير } from "../Expressions.js";
import { إدارة_المسافة_البادئة } from "../Indentation.js";
import { إنشاء_الشفرة } from "../../AlifGenerator.js";
import { رمي_خطأ } from "../AlifErrors.js";
import { ذاكرة, تحديث_ذاكرة_المتغير } from "../AlifMemory.js";

export function محلل_لاجل(الرموز, الدالة_الام) {
    if (!الرموز || !Array.isArray(الرموز)) {
        throw new Error('الرموز غير معرفة أو غير صحيحة "محلل_لاجل" ' + الرموز);
    }
    تطابق(الرموز, "كلمة", "لاجل") || تطابق(الرموز, "كلمة", "لأجل");
    const السطر = احصل(الرموز).السطر;
    // تخطي المسافات والاسطر الفارغة
    while (تحقق(الرموز, "مسافة")) التالي(الرموز);

    const معرف_متغير = تطابق(الرموز, "معرف");
    if (!معرف_متغير)
        رمي_خطأ(`يجب تحديد اسم متغير بعد لاجل`, الرموز, الدالة_الام);

    const المتغير = { نوع: "معرف", اسم: معرف_متغير.القيمة };

    if (!تطابق(الرموز, "رمز_حسابي", "في"))
        رمي_خطأ(`يجب اضافة كلمة "في" بعد متغير لاجل`, الرموز, الدالة_الام);

    let الحدود = [];
    let مدى = false;
    if (تحقق(الرموز, "معرف", "مدى")) {
        تطابق(الرموز, "معرف", "مدى");
        مدى = true;

        if (!تطابق(الرموز, "اقواس", "("))
            رمي_خطأ(
                `يجب فتح قوس "(" بعد كلمة "مدى" في لاجل`,
                الرموز,
                الدالة_الام
            );

        while (!تحقق(الرموز, "اقواس", ")")) {
            const قيمة = محلل_التعبير(الرموز, الدالة_الام);
            if (!قيمة) رمي_خطأ(`لا يوجد حد صحيح في لاجل`, الرموز, الدالة_الام);

            الحدود.push(قيمة);
            if (تحقق(الرموز, "فاصلة")) التالي(الرموز);
            else break;
        }

        if (!تطابق(الرموز, "اقواس", ")"))
            رمي_خطأ(
                `لم يتم اغلاق القوس ")" بعد حدود لاجل`,
                الرموز,
                الدالة_الام
            );
    } else if (تحقق(الرموز, "اقواس", "(")) {
        if (!تطابق(الرموز, "اقواس", "("))
            رمي_خطأ(`يجب فتح قوس "(" في لاجل`, الرموز, الدالة_الام);

        while (!تحقق(الرموز, "اقواس", ")")) {
            const قيمة = محلل_التعبير(الرموز, الدالة_الام);
            if (!قيمة) رمي_خطأ(`لا يوجد حد صحيح في لاجل`, الرموز, الدالة_الام);

            الحدود.push(قيمة);
            if (تحقق(الرموز, "فاصلة")) التالي(الرموز);
            else break;
        }

        if (!تطابق(الرموز, "اقواس", ")"))
            رمي_خطأ(
                `لم يتم اغلاق القوس ")" بعد حدود لاجل`,
                الرموز,
                الدالة_الام
            );
    } else {
        الحدود = محلل_التعبير(الرموز, الدالة_الام);
    }

    if (الحدود.length == 0)
        رمي_خطأ(`لا يوجد حد صحيح في لاجل`, الرموز, الدالة_الام);

    if (!تطابق(الرموز, "نقطتان"))
        رمي_خطأ(`توقعت ":" بعد تعريف لاجل`, الرموز, الدالة_الام);

    // ما بداخل العجلة
    const اوامر = إدارة_المسافة_البادئة(الرموز, الدالة_الام, " لاجل");
    if (!تحقق(الرموز, "مسافة")) {
        return {
            نوع: "لاجل",
            المتغير,
            الحدود,
            اوامر,
            مدى,
            الدالة_الام,
        };
    }
    return {
        نوع: "لاجل",
        المتغير,
        الحدود,
        اوامر,
        مدى,
        الدالة_الام,
    };
}

export function منشئ_لاجل(مستوى, عداد, عقدة, داخل_برنامج) {
    const المتغير = عقدة.المتغير;

    let الحدود = Array.isArray(عقدة.الحدود)
        ? عقدة.الحدود.map((ج) => إنشاء_الشفرة(ج, مستوى + 1, عداد, داخل_برنامج))
        : [إنشاء_الشفرة(عقدة.الحدود, مستوى + 1, عداد, داخل_برنامج)];

    const اوامر = عقدة.اوامر
        .map((ج) => إنشاء_الشفرة(ج, مستوى + 1, عداد, داخل_برنامج))
        .join("\n");

    let تعريف_المتغير = "";

    if (المتغير && المتغير.اسم)
        if (!ذاكرة.متغير_موجود(عقدة.الدالة_الام, المتغير.اسم)) {
            تحديث_ذاكرة_المتغير(عقدة.الدالة_الام, المتغير.اسم, "");
            تعريف_المتغير += `let ${المتغير.اسم};\n`;
        }

    const متغير_المصفوفة = (س) =>
        ذاكرة.نوع_المتغير(الحدود[س]) == "مصفوفة" ? true : false;

    if (الحدود.length == 1 && متغير_المصفوفة(0)) {
        return `${تعريف_المتغير}for (${المتغير.اسم} of ${الحدود[0]}) {\n\t${اوامر}\n}`;
    } else if ((الحدود.length == 2 || الحدود.length == 3) && عقدة.مدى) {
        return `${تعريف_المتغير}for (${المتغير.اسم} of مدى(${الحدود[0]}, ${الحدود[1]}, ${الحدود[2]})) {\n\t${اوامر}\n}`;
    } else if (الحدود.length > 1 && !عقدة.مدى) {
        return `${تعريف_المتغير}for (${المتغير.اسم} of [${الحدود}]) {\n\t${اوامر}\n}`;
    }

    return `${تعريف_المتغير}for (${المتغير.اسم} = 0; ${المتغير.اسم} < ${الحدود}; ${المتغير.اسم}++) {\n\t${اوامر}\n}`;
}
