import { احصل, التالي, تحقق, تطابق } from "../TokenUtils.js";
import { محلل_التعبير } from "../Expressions.js";
import { محلل_الجملة } from "../../AlifParser.js";
import { إنشاء_الشفرة } from "../../AlifGenerator.js";

export function محلل_لاجل(الرموز) {
    if (!الرموز || !Array.isArray(الرموز)) {
        throw new Error('الرموز غير معرفة أو غير صحيحة "محلل_لاجل" ' + الرموز);
    }
    تطابق(الرموز, "كلمة", "لاجل") || تطابق(الرموز, "كلمة", "لأجل");
    // تخطي المسافات والاسطر الفارغة
    while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد")) التالي(الرموز);

    const معرف_متغير = تطابق(الرموز, "معرف");
    if (!معرف_متغير) {
        const error = new Error(`يجب تحديد اسم متغير بعد لاجل`);
        error.line = `في السطر ` + احصل(الرموز).السطر;
        throw error;
    }
    const المتغير = { نوع: "معرف", اسم: معرف_متغير.القيمة };

    تطابق(الرموز, "كلمة", "في");

    let الحدود = [];
    if (تحقق(الرموز, "معرف", "مدى")) {
        تطابق(الرموز, "معرف", "مدى");
        تطابق(الرموز, "اقواس", "(");
        while (!تحقق(الرموز, "اقواس", ")")) {
            const قيمة = محلل_التعبير(الرموز);
            if (!قيمة) {
                const error = new Error(`لا يوجد حد صحيح في لاجل`);
                error.line = `في السطر ` + احصل(الرموز).السطر;
                throw error;
            }
            الحدود.push(قيمة);
            if (تحقق(الرموز, "فاصلة")) التالي(الرموز);
        }
        تطابق(الرموز, "اقواس", ")");
    } else if (تحقق(الرموز, "اقواس", "(")) {
        تطابق(الرموز, "اقواس", "(");
        while (!تحقق(الرموز, "اقواس", ")")) {
            const قيمة = محلل_التعبير(الرموز);
            if (!قيمة) {
                const error = new Error(`لا يوجد حد صحيح في لاجل`);
                error.line = `في السطر ` + احصل(الرموز).السطر;
                throw error;
            }
            الحدود.push(قيمة);
            if (تحقق(الرموز, "فاصلة")) التالي(الرموز);
        }
        تطابق(الرموز, "اقواس", ")");
    } else {
        الحدود = محلل_التعبير(الرموز);
    }
    if (!الحدود) {
        const error = new Error(`لا يوجد حد صحيح في لاجل`);
        error.line = `في السطر ` + احصل(الرموز).السطر;
        throw error;
    }

    if (!تطابق(الرموز, "نقطتان")) {
        const error = new Error(`توقعت ":" بعد تعريف لاجل`);
        error.line = `في السطر ` + احصل(الرموز).السطر;
        throw error;
    }

    // ما بداخل العجلة
    const اوامر = [];
    while (تحقق(الرموز, "سطر_جديد")) التالي(الرموز);
    if (!تحقق(الرموز, "مسافة")) {
        return { نوع: "لاجل", المتغير, الحدود, اوامر };
    }
    const التبويب = احصل(الرموز).القيمة.length;
    التالي(الرموز);
    const جملة = محلل_الجملة(الرموز);
    if (!جملة) {
        const error = new Error(`لا يوجد جملة صحيحة في لاجل`);
        error.line = `في السطر ` + احصل(الرموز).السطر;
        throw error;
    }
    اوامر.push(جملة);
    while (true) {
        while (تحقق(الرموز, "سطر_جديد")) التالي(الرموز);
        if (!تحقق(الرموز, "مسافة") || احصل(الرموز).القيمة.length < التبويب)
            break;
        التالي(الرموز);
        const جملة = محلل_الجملة(الرموز);
        if (!جملة) {
            const error = new Error(`لا يوجد جملة صحيحة في لاجل`);
            error.line = `في السطر ` + احصل(الرموز).السطر;
            throw error;
        }
        اوامر.push(جملة);
    }

    return { نوع: "لاجل", المتغير, الحدود, اوامر };
}

export function منشئ_لاجل(مستوى, عداد, عقدة, داخل_برنامج) {
    const المتغير = عقدة.المتغير;

    let الحدود = Array.isArray(عقدة.الحدود)
        ? عقدة.الحدود.map((ج) => إنشاء_الشفرة(ج, مستوى + 1, عداد, داخل_برنامج))
        : [إنشاء_الشفرة(عقدة.الحدود, مستوى + 1, عداد, داخل_برنامج)];

    const اوامر = عقدة.اوامر
        .map((ج) => إنشاء_الشفرة(ج, مستوى + 1, عداد, داخل_برنامج))
        .join("\n");

    // تصحيح التحقق من النوع
    const رقم1 = Number(الحدود[0]);
    const رقم2 = Number(الحدود[1]);
    const رقم3 = Number(الحدود[2]);

    if (الحدود.length == 1 && isNaN(رقم1)) {
        return `for (let ${المتغير.اسم} of ${الحدود[0]}) {\n\t${اوامر}\n}`;
    } else if (
        الحدود.length == 3 &&
        !isNaN(رقم1) &&
        !isNaN(رقم2) &&
        !isNaN(رقم3)
    ) {
        return `for (let ${المتغير.اسم} of مدى(${الحدود[0]}, ${الحدود[1]}, ${الحدود[2]})) {\n\t${اوامر}\n}`;
    } else if (
        الحدود.length > 1 &&
        (isNaN(رقم1) || isNaN(رقم2) || isNaN(رقم3))
    ) {
        return `for (let ${المتغير.اسم} of [${الحدود}]) {\n\t${اوامر}\n}`;
    }

    return `for (let ${المتغير.اسم} = 0; ${المتغير.اسم} < ${الحدود}; ${المتغير.اسم}++) {\n\t${اوامر}\n}`;
}
