import { احصل, التالي, تحقق, تطابق } from "../TokenUtils.js";
import { إدارة_المسافة_البادئة } from "../Indentation.js";
import { إنشاء_الشفرة } from "../../AlifGenerator.js";
import { محلل_الجملة } from "../../AlifParser.js";
import { رمي_خطأ } from "../AlifErrors.js";
import { ذاكرة_الدوال } from "./AlifFunction.js";

export function محلل_صنف(الرموز) {
    تطابق(الرموز, "كلمة", "صنف");

    const اسم = تطابق(الرموز, "معرف");
    if (!اسم) رمي_خطأ("لا يوجد اسم للصنف", الرموز);

    ذاكرة_الدوال.push(اسم.القيمة);

    const معاملات = [];
    if (تحقق(الرموز, "اقواس", "(")) {
        تطابق(الرموز, "اقواس", "(");
        while (!تحقق(الرموز, "اقواس", ")")) {
            if (تحقق(الرموز, "معرف")) {
                const اسم_المعرف = احصل(الرموز).القيمة;
                التالي(الرموز);

                if (تحقق(الرموز, "علامة_إسناد")) {
                    التالي(الرموز);
                    const قيمة = محلل_الجملة(الرموز);
                    if (قيمة) {
                        معاملات.push({
                            اسم: اسم_المعرف,
                            قيمة: قيمة.رمز.القيمة,
                        });
                    }
                } else {
                    معاملات.push({ قيمة: اسم_المعرف });
                }
            } else {
                const قيمة = محلل_الجملة(الرموز);
                if (قيمة) معاملات.push({ قيمة: قيمة.القيمة });
            }
            if (تحقق(الرموز, "فاصلة")) التالي(الرموز);
        }
        if (!تطابق(الرموز, "اقواس", ")"))
            رمي_خطأ(`لم يتم اغلاق القوس ")"`, الرموز);
    }

    if (!تطابق(الرموز, "نقطتان")) رمي_خطأ(`توقعت ":" بعد تعريف الصنف`, الرموز);

    const اوامر = إدارة_المسافة_البادئة(الرموز, "صنف");
    if (!تحقق(الرموز, "مسافة")) {
        return { نوع: "صنف", اسم: اسم.القيمة, معاملات, اوامر };
    }
    return {
        نوع: "صنف",
        اسم: اسم.القيمة,
        معاملات,
        اوامر,
    };
}

export function منشئ_صنف(مستوى, عداد, عقدة, داخل_برنامج) {
    const اسم = عقدة.اسم;
    const معاملات = Array.isArray(عقدة.معاملات)
        ? عقدة.معاملات
              .map((م) => {
                  if (م.اسم) {
                      return `${م.اسم} = ${م.قيمة}`;
                  }
                  return م.قيمة;
              })
              .join(", ")
        : "فارغ";
    const اوامر = عقدة.اوامر
        .map((ج) => إنشاء_الشفرة(ج, مستوى + 1, عداد, داخل_برنامج))
        .join("\n");

    if (معاملات === "") return `class ${اسم} {\n${اوامر}\n}`;
    return `class ${اسم} extends ${معاملات} {\n${اوامر}\n}`;
}
