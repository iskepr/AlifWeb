import { تحقق, تطابق, السابق, التالي, احصل } from "../TokenUtils.js";
import { محلل_التعبير } from "../Expressions.js";
import { إنشاء_الشفرة } from "../../AlifGenerator.js";
import { رمي_خطأ } from "../AlifErrors.js";

export let ذاكرة_المتغيرات = [];

export function محلل_متغير(الرموز, الدالة_الام) {
    if (!الرموز || !Array.isArray(الرموز)) {
        throw new Error('الرموز غير معرفة أو غير صحيحة "محلل_متغير" ' + الرموز);
    }
    let أول;
    let أسماء = [];
    let أسماء_صنف = [];

    if (تحقق(الرموز, "معرف", "هذا")) {
        أسماء_صنف.push(تطابق(الرموز, "معرف", "هذا").القيمة);
        أسماء_صنف.push(تطابق(الرموز, "نقطة").القيمة);
        أسماء_صنف.push(تطابق(الرموز, "معرف").القيمة);
    } else {
        أول = تطابق(الرموز, "معرف");

        // دعم المتغيرات المتعددة مثل: س,ص = 7, 9
        if (!أول) return null;

        // دعم س[5]
        let اسم_المتغير = أول.القيمة;
        if (تحقق(الرموز, "اقواس", "[")) {
            التالي(الرموز); // تخطي الـ '['
            const الفهرس = محلل_التعبير(الرموز, الدالة_الام);
            if (!تطابق(الرموز, "اقواس", "]")) {
                رمي_خطأ('توقع إغلاق القوس "]"', الرموز, الدالة_الام);
            }
            اسم_المتغير = `${اسم_المتغير}[${الفهرس.قيمة || الفهرس.اسم}]`;
        }

        أسماء = [اسم_المتغير];

        // جمع أي معرفات إضافية مفصولة بفاصلة
        if (تحقق(الرموز, "فاصلة")) {
            while (تحقق(الرموز, "فاصلة")) {
                تطابق(الرموز, "فاصلة");
                const t = تطابق(الرموز, "معرف");
                if (!t)
                    رمي_خطأ(
                        `لا يوجد اسم متغير بعد الفاصلة`,
                        الرموز,
                        الدالة_الام
                    );

                let متغير = t.القيمة;
                // دعم الفهارس للمتغيرات الإضافية
                if (تحقق(الرموز, "اقواس", "[")) {
                    التالي(الرموز); // تخطي الـ '['
                    const الفهرس = محلل_التعبير(الرموز, الدالة_الام);
                    if (!تطابق(الرموز, "اقواس", "]")) {
                        رمي_خطأ('توقع إغلاق القوس "]"', الرموز, الدالة_الام);
                    }
                    متغير = { نوع: "فهرس_عنصر", قائمة: متغير, فهرس: الفهرس };
                }

                أسماء.push(متغير);
            }
        }
    }

    // تحقق من وجود علامة الإسناد
    if (تحقق(الرموز, "علامة_إسناد", "=") && تطابق(الرموز, "علامة_إسناد", "=")) {
        التالي(الرموز);
        if (تحقق(الرموز, "كلمة", "إذا") || تحقق(الرموز, "كلمة", "اذا")) {
            التالي(الرموز);
        }
        السابق(الرموز);
        const قيم = [];
        const قيمة = محلل_التعبير(الرموز, الدالة_الام);
        if (!قيمة)
            رمي_خطأ(`لا يوجد قيمة بعد علامة الإسناد`, الرموز, الدالة_الام);

        قيم.push(قيمة);

        // جمع أي قيم إضافية مفصولة بفاصلة
        while (تحقق(الرموز, "فاصلة")) {
            تطابق(الرموز, "فاصلة");
            const قيمة = محلل_التعبير(الرموز, الدالة_الام);
            if (!قيمة) رمي_خطأ(`لا يوجد قيمة بعد الفاصلة`, الرموز, الدالة_الام);

            قيم.push(قيمة);
        }

        // إذا كان تعيين واحد فقط
        if (
            (أسماء.length === 1 && قيم.length === 1) ||
            أسماء_صنف.length === 3
        ) {
            return {
                نوع: "متغير",
                اسم: أسماء[0],
                أسماء_صنف,
                قيمة: قيم[0],
                الدالة_الام,
            };
        } else if (أسماء.length === 1 && قيم.length > 1) {
            return {
                نوع: "متغير",
                اسم: أسماء[0],
                أسماء_صنف,
                قيمة: قيم,
                الدالة_الام,
            };
        }

        // تعيين متعدد
        return { نوع: "متغير_مجمع", أسماء, أسماء_صنف, قيم, الدالة_الام };
    }

    السابق(الرموز);
    return محلل_التعبير(الرموز, الدالة_الام);
}

export function تحديث_ذاكرة_المتغير(اسم, قيمة, الدالة_الام) {
    let نوع_القيمة;
    const مصفوفة = قيمة.trim().startsWith("[") && قيمة.trim().endsWith("]");
    const فهرس = قيمة.trim().startsWith("{") && قيمة.trim().endsWith("}");
    const رقم = !isNaN(قيمة);
    const نص =
        (قيمة.trim().startsWith('"') && قيمة.trim().endsWith('"')) ||
        (قيمة.trim().startsWith("'") && قيمة.trim().endsWith("'"));

    if (مصفوفة) نوع_القيمة = "مصفوفة";
    else if (فهرس) نوع_القيمة = "فهرس";
    else if (رقم) نوع_القيمة = "رقم";
    else if (نص) نوع_القيمة = "نص";
    else نوع_القيمة = "امر";

    const موجود = ذاكرة_المتغيرات.findIndex((م) => م.الاسم === اسم);
    if (موجود !== -1) {
        ذاكرة_المتغيرات[موجود].القيمة = قيمة;
        ذاكرة_المتغيرات[موجود].نوع_القيمة = نوع_القيمة;
        ذاكرة_المتغيرات[موجود].الدالة_الام = الدالة_الام;
    } else {
        ذاكرة_المتغيرات.push({
            الاسم: اسم,
            القيمة: قيمة,
            نوع_القيمة,
            الدالة_الام,
        });
    }
}

export function منشئ_متغير(مستوى, عداد, عقدة) {
    let هو_معلن;
    let الاسم = عقدة.اسم;
    const أسماء_صنف = عقدة.أسماء_صنف;
    const الدالة_الام = عقدة.الدالة_الام;

    if (!الاسم) {
        هو_معلن = true;
        الاسم =
            (أسماء_صنف[0] === "هذا" ? "this" : أسماء_صنف[0]) +
            أسماء_صنف[1] +
            أسماء_صنف[2];
    } else {
        if (!عداد.بحث_متغير) {
            عداد.بحث_متغير = new Set();
        }
        const المفتاح = `${الاسم}::${الدالة_الام}`;
        هو_معلن = عداد.بحث_متغير.has(المفتاح);
    }

    let القيمة;
    if (Array.isArray(عقدة.قيمة)) {
        القيمة = عقدة.قيمة
            .map((قيمة) => إنشاء_الشفرة(قيمة, مستوى, عداد))
            .join(", ");
        القيمة = `[${القيمة}]`;
    } else {
        القيمة = إنشاء_الشفرة(عقدة.قيمة, مستوى, عداد);
    }

    const المفتاح = `${الاسم}::${الدالة_الام}`;

    if (هو_معلن || الاسم.includes("[")) {
        if (!الاسم.includes("[")) {
            تحديث_ذاكرة_المتغير(الاسم, القيمة, الدالة_الام);
        }
        return `${الاسم} = ${القيمة};`;
    } else {
        if (!الاسم.includes("[")) {
            تحديث_ذاكرة_المتغير(الاسم, القيمة, الدالة_الام);
        }
        عداد.بحث_متغير.add(المفتاح);
        return `let ${الاسم} = ${القيمة};`;
    }
}

export function منشئ_متغير_مجمع(مستوى, عداد, عقدة) {
    if (!عداد.بحث_متغير) عداد.بحث_متغير = new Set();

    const أسماء = عقدة.أسماء;
    const الدالة_الام = عقدة.الدالة_الام;
    const قيم = عقدة.قيم.map((v) => إنشاء_الشفرة(v, مستوى, عداد));

    return أسماء
        .map((الاسم, index) => {
            const قيمة = قيم[index] !== undefined ? قيم[index] : "undefined";
            const المفتاح = `${الاسم}::${الدالة_الام}`;

            if (عداد.بحث_متغير.has(المفتاح) || الاسم.includes("[")) {
                if (!الاسم.includes("[")) {
                    تحديث_ذاكرة_المتغير(الاسم, قيمة, الدالة_الام);
                }
                return `${الاسم} = ${قيمة};`;
            } else {
                if (!الاسم.includes("[")) {
                    تحديث_ذاكرة_المتغير(الاسم, قيمة, الدالة_الام);
                }
                عداد.بحث_متغير.add(المفتاح);
                return `let ${الاسم} = ${قيمة};`;
            }
        })
        .join("\n");
}
