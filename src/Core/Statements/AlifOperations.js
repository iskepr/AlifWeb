import { احصل, التالي, السابق, تحقق, تطابق } from "../TokenUtils.js";
import { محلل_التعبير } from "../Expressions.js";
import { إنشاء_الشفرة } from "../../AlifGenerator.js";
import { رمي_خطأ } from "../AlifErrors.js";

// القيمة الأعلى = تنفيذ أولاً
const أولويات_العمليات = {
    "^": 5,
    "\\^": 5,
    "*": 4,
    "\\": 4,
    "\\\\": 4,
    "\\*": 4,
    "+": 3,
    "-": 3,

    // المقارنات
    "<": 2,
    ">": 2,
    "==": 2,
    "!=": 2,
    "<=": 2,
    ">=": 2,

    // المنطقي
    و: 1,
    او: 1,
    أو: 1,
    ليس: 1,
    "ليس في": 1,
    في: 1,

    // الإسناد
    "+=": 0,
    "-=": 0,
    "*=": 0,
    "\\=": 0,
    "^=": 0,
    "\\*=": 0,
    "\\\\=": 0,
};

export function محلل_العمليات(الرموز, الدالة_الام) {
    if (!Array.isArray(الرموز)) {
        throw new Error("الرموز غير معرفة أو غير صحيحة في محلل_العمليات");
    }
    return محلل_التعبير_مع_الأولوية(الرموز, -Infinity, الدالة_الام);
}

// قراءة عامل مفرد (رقم، معرف، تعبير بين قوسين أو أحادي)
function قراءة_عامل(الرموز, الدالة_الام) {
    while (تحقق(الرموز, "مسافة")) التالي(الرموز);

    // تعبير بالقوسين
    if (تطابق(الرموز, "اقواس", "(")) {
        const عقدة = محلل_التعبير_مع_الأولوية(الرموز, -Infinity, الدالة_الام);
        if (!تطابق(الرموز, "اقواس", ")"))
            رمي_خطأ(`لم يتم اغلاق القوس ")" بعد العمليات`, الرموز, "عملية");
        return عقدة;
    }

    // أحادي (سالب أو جذر)
    if (تحقق(الرموز, "رمز_حسابي", "-")) {
        التالي(الرموز);
        const عامل = قراءة_عامل(الرموز, الدالة_الام, الدالة_الام);
        return {
            نوع: "عملية",
            القيم: {
                يسار: { نوع: "عدد", قيمة: 0 },
                عامل: { نوع: "رمز_حسابي", قيمة: "-" },
                يمين: عامل,
            },
        };
    }
    if (تحقق(الرموز, "رمز_حسابي", "\\^")) {
        التالي(الرموز);
        const عامل = قراءة_عامل(الرموز, الدالة_الام);
        return {
            نوع: "عملية",
            القيم: {
                يسار: عامل,
                عامل: { نوع: "رمز_حسابي", قيمة: "\\^" },
                يمين: عامل,
            },
        };
    }
    if (تحقق(الرموز, "رمز_حسابي", "ليس")) {
        التالي(الرموز);
        const عامل = محلل_التعبير_مع_الأولوية(الرموز, 1, الدالة_الام);
        return {
            نوع: "عملية",
            القيم: {
                يسار: عامل,
                عامل: { نوع: "رمز_حسابي", قيمة: "ليس" },
                يمين: عامل,
            },
        };
    }

    // رقم أو معرف أو كلمة
    if (تحقق(الرموز, "كلمة", "صحيح") || تحقق(الرموز, "كلمة", "عشري")) {
        return محلل_التعبير(الرموز);
    }
    if (تطابق(الرموز, "اقواس", "[")) {
        let قيم = [];
        while (!تحقق(الرموز, "اقواس", "]")) {
            // تخطي المسافات والاسطر الفارغة
            while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد"))
                التالي(الرموز);
            const القيمة = محلل_التعبير(الرموز);
            if (!القيمة) رمي_خطأ(`خطأ في قيم القائمة`, الرموز, "مصفوفة");
            قيم.push(إنشاء_الشفرة(القيمة));
            // اذا لا يوجد فاصلة توقف
            if (تحقق(الرموز, "فاصلة")) التالي(الرموز);
            else break;
        }
        if (!تطابق(الرموز, "اقواس", "]"))
            رمي_خطأ(`لم يتم اغلاق القوس "]"`, الرموز, "مصفوفة");
        return {
            نوع: "عدد",
            قيمة: `[${قيم.join(",")}]`,
        };
    }
    const tok = تطابق(الرموز, "رقم") || تطابق(الرموز, "معرف");
    if (tok) {
        if (تطابق(الرموز, "اقواس", "[")) {
            const القيمة = محلل_التعبير(الرموز);
            التالي(الرموز);
            تطابق(الرموز, "اقواس", "]");
            return {
                نوع: "عدد",
                قيمة: `${tok.القيمة}[${إنشاء_الشفرة(القيمة)}]`,
            };
        }
        const val = !isNaN(Number(tok.القيمة))
            ? Number(tok.القيمة)
            : tok.القيمة;
        return { نوع: "عدد", قيمة: val };
    }
    رمي_خطأ(`متوقع رقم أو معرف أو عامل`, الرموز, الدالة_الام);
}

// محلل التعبير مع الأولويات
function محلل_التعبير_مع_الأولوية(الرموز, اقل_اولوية, الدالة_الام) {
    let عقدة = قراءة_عامل(الرموز, الدالة_الام);
    let آخر_عنصر = عقدة;

    while (true) {
        while (تحقق(الرموز, "مسافة")) التالي(الرموز);
        if (!تحقق(الرموز, "رمز_حسابي")) break;

        const الرمز = تطابق(الرموز, "رمز_حسابي");
        const الأولوية = أولويات_العمليات[الرمز.القيمة] ?? -Infinity;

        if (الأولوية <= اقل_اولوية) {
            السابق(الرموز);
            break;
        }

        const يمين = محلل_التعبير_مع_الأولوية(الرموز, الأولوية, الدالة_الام);

        if (["==", "!=", "<", ">", "<=", ">="].includes(الرمز.القيمة)) {
            // بناء عقدة المقارنة الجديدة
            const عقدة_مقارنة_جديدة = {
                نوع: "عملية",
                القيم: {
                    يسار: آخر_عنصر,
                    عامل: { نوع: "رمز_حسابي", قيمة: الرمز.القيمة },
                    يمين: يمين,
                },
            };

            if (عقدة === آخر_عنصر) {
                // أول مقارنة في السلسلة
                عقدة = عقدة_مقارنة_جديدة;
            } else {
                عقدة = {
                    نوع: "عملية",
                    القيم: {
                        يسار: عقدة,
                        عامل: { نوع: "رمز_حسابي", قيمة: "و" },
                        يمين: عقدة_مقارنة_جديدة,
                    },
                };
            }

            // تحديث آخر عنصر للقيمة الجديدة
            آخر_عنصر = يمين;
        } else {
            // معالجة عادية للعمليات الأخرى
            عقدة = {
                نوع: "عملية",
                القيم: {
                    يسار: عقدة,
                    عامل: { نوع: "رمز_حسابي", قيمة: الرمز.القيمة },
                    يمين: يمين,
                },
            };
            آخر_عنصر = يمين; // تحديث آخر عنصر
        }
    }

    return عقدة;
}

// إنشاء شفرة جافاسكربت من الشجرة
export function منشئ_عمليات(عقدة, مستوى, عداد) {
    const { يسار: L, عامل, يمين: R } = عقدة.القيم;
    let يسار =
        L.type === "عملية"
            ? منشئ_عمليات(L, مستوى, عداد)
            : L.نوع === "عدد"
            ? L.قيمة
            : إنشاء_الشفرة(L, مستوى, عداد);
    let يمين =
        R.type === "عملية"
            ? منشئ_عمليات(R, مستوى, عداد)
            : R.نوع === "عدد"
            ? R.قيمة
            : إنشاء_الشفرة(R, مستوى, عداد);

    let مع_متغير =
        typeof يسار == "number" && typeof يمين == "number" ? false : true;

    let الناتج = null;
    const عمليات = {
        "\\": "/",
        "\\\\": "%",
        "\\=": "/=",
        و: "&&",
        او: "||",
        أو: "||",
    };

    if (عمليات[عامل.قيمة]) {
        الناتج = مع_متغير
            ? `${يسار} ${عمليات[عامل.قيمة]} ${يمين}`
            : eval(`${يسار} ${عمليات[عامل.قيمة]} ${يمين}`);
    } else {
        switch (عامل.قيمة) {
            case "^":
                الناتج = مع_متغير
                    ? `Math.pow(${يسار}, ${يمين})`
                    : Math.pow(يسار, يمين);
                break;
            case "\\^":
                الناتج = مع_متغير ? `Math.sqrt(${يمين})` : Math.sqrt(يمين);
                break;
            case "+=":
            case "-=":
            case "*=":
            case "==":
            case "+":
            case "-":
            case "*":
            case ">":
            case "<":
            case "!=":
            case ">=":
            case "<=":
                الناتج = `${يسار} ${عامل.قيمة} ${يمين}`;
                break;
            case "^=":
                الناتج = `${يسار} = Math.pow(${يسار}, ${يمين})`;
                break;
            case "\\\\=":
                الناتج = `${يسار} %= ${يمين}`;
                break;
            case "\\*":
                الناتج = مع_متغير
                    ? `Math.floor(${يسار} / ${يمين})`
                    : Math.floor(يسار / يمين);
                break;
            case "\\*=":
                الناتج = `${يسار} = Math.floor(${يسار} / ${يمين})`;
                break;
            case "ليس":
                الناتج = مع_متغير ? `!(${يسار})` : !يسار;
                break;
            case "ليس في":
                الناتج = `(!${يمين}.includes(${يسار}))`;
                break;
            case "في":
                الناتج = `(${يمين}.includes(${يسار}))`;
                break;
            default:
                throw new Error("رمز حسابي غير معروف");
        }
    }

    return مع_متغير ? الناتج : الناتج.toString();
}
