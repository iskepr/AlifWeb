import { احصل, التالي, السابق, تحقق, تطابق } from "../TokenUtils.js";
import { محلل_التعبير } from "../Expressions.js";
import { إنشاء_الشفرة } from "../../AlifGenerator.js";
import { رمي_خطأ } from "../AlifErrors.js";

// القيمة الأعلى = تنفيذ أولاً
const أولويات_العمليات = {
    "^": 5,
    "\\^": 5,
    "*": 4,
    "\\": 4,
    "\\\\": 4,
    "\\*": 4,
    "+": 3,
    "-": 3,

    // المقارنات
    "<": 2,
    ">": 2,
    "==": 2,
    "!=": 2,
    "<=": 2,
    ">=": 2,

    // المنطقي
    و: 1,
    او: 1,
    أو: 1,
    ليس: 1,
    "ليس في": 1,

    // الإسناد
    "+=": 0,
    "-=": 0,
    "*=": 0,
    "\\=": 0,
    "^=": 0,
    "\\*=": 0,
    "\\\\=": 0,
};

export function محلل_العمليات(الرموز) {
    if (!Array.isArray(الرموز)) {
        throw new Error("الرموز غير معرفة أو غير صحيحة في محلل_العمليات");
    }
    return محلل_التعبير_مع_الأولوية(الرموز, -Infinity);
}

// قراءة عامل مفرد (رقم، معرف، تعبير بين قوسين أو أحادي)
function قراءة_عامل(الرموز) {
    while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد")) التالي(الرموز);

    // تعبير بالقوسين
    if (تطابق(الرموز, "اقواس", "(")) {
        const عقدة = محلل_التعبير_مع_الأولوية(الرموز, -Infinity);
        if (!تطابق(الرموز, "اقواس", ")"))
            رمي_خطأ(`لم يتم اغلاق القوس ")"`, الرموز);
        return عقدة;
    }

    // أحادي (سالب أو جذر)
    if (تحقق(الرموز, "رمز_حسابي", "-")) {
        التالي(الرموز);
        const عامل = قراءة_عامل(الرموز);
        return {
            نوع: "عملية",
            القيم: {
                يسار: { نوع: "عدد", قيمة: 0 },
                عامل: { نوع: "رمز_حسابي", قيمة: "-" },
                يمين: عامل,
            },
        };
    }
    if (تحقق(الرموز, "رمز_حسابي", "\\^")) {
        التالي(الرموز);
        const عامل = قراءة_عامل(الرموز);
        return {
            نوع: "عملية",
            القيم: {
                يسار: عامل,
                عامل: { نوع: "رمز_حسابي", قيمة: "\\^" },
                يمين: عامل,
            },
        };
    }

    // رقم أو معرف أو كلمة
    if (تحقق(الرموز, "كلمة", "صحيح") || تحقق(الرموز, "كلمة", "عشري")) {
        return محلل_التعبير(الرموز);
    }
    const tok =
        تطابق(الرموز, "رقم") || تطابق(الرموز, "معرف") || تطابق(الرموز, "نص");
    if (tok) {
        if (تطابق(الرموز, "اقواس", "[")) {
            const القيمة = احصل(الرموز);
            التالي(الرموز);
            if (!تطابق(الرموز, "اقواس", "]"))
                رمي_خطأ(`لم يتم اغلاق القوس "]"`, الرموز);
            return {
                نوع: "عدد",
                قيمة: `${tok.القيمة}[${القيمة.القيمة}]`,
            };
        }
        const val = !isNaN(Number(tok.القيمة))
            ? Number(tok.القيمة)
            : tok.القيمة;
        return { نوع: "عدد", قيمة: val };
    }
    رمي_خطأ(`متوقع رقم أو معرف أو عامل`, الرموز);
}

// محلل التعبير مع الأولويات
function محلل_التعبير_مع_الأولوية(الرموز, minPrec) {
    let عقدة = قراءة_عامل(الرموز);

    while (true) {
        while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد"))
            التالي(الرموز);
        if (!تحقق(الرموز, "رمز_حسابي")) break;
        const op = تطابق(الرموز, "رمز_حسابي");
        const prec = أولويات_العمليات[op.القيمة] ?? -Infinity;
        if (prec <= minPrec) {
            السابق(الرموز);
            break;
        }
        const يمين = محلل_التعبير_مع_الأولوية(الرموز, prec);
        عقدة = {
            نوع: "عملية",
            القيم: {
                يسار: عقدة,
                عامل: { نوع: "رمز_حسابي", قيمة: op.القيمة },
                يمين: يمين,
            },
        };
    }
    return عقدة;
}

// إنشاء شفرة جافاسكربت من الشجرة
export function منشئ_عمليات(عقدة, مستوى, عداد) {
    const { يسار: L, عامل, يمين: R } = عقدة.القيم;
    let يسار =
        L.type === "عملية"
            ? منشئ_عمليات(L, مستوى, عداد)
            : L.نوع === "عدد"
            ? L.قيمة
            : إنشاء_الشفرة(L, مستوى, عداد);
    let يمين =
        R.type === "عملية"
            ? منشئ_عمليات(R, مستوى, عداد)
            : R.نوع === "عدد"
            ? R.قيمة
            : إنشاء_الشفرة(R, مستوى, عداد);

    let مع_متغير =
        typeof يسار == "number" && typeof يمين == "number" ? false : true;

    let الناتج = null;
    switch (عامل.قيمة) {
        case "+":
            مع_متغير ? (الناتج = `${يسار} + ${يمين}`) : (الناتج = يسار + يمين);
            break;
        case "-":
            مع_متغير ? (الناتج = `${يسار} - ${يمين}`) : (الناتج = يسار - يمين);
            break;
        case "*":
            مع_متغير ? (الناتج = `${يسار} * ${يمين}`) : (الناتج = يسار * يمين);
            break;
        case "\\":
            مع_متغير ? (الناتج = `${يسار} / ${يمين}`) : (الناتج = يسار / يمين); // قسمة
            break;
        case "\\\\": // باقي القسمة
            مع_متغير ? (الناتج = `${يسار} % ${يمين}`) : (الناتج = يسار % يمين);
            break;
        case "\\*": // ناتج القسمة
            مع_متغير
                ? (الناتج = `Math.floor(${يسار} / ${يمين})`)
                : (الناتج = Math.floor(يسار / يمين));
            break;
        case "^":
            مع_متغير
                ? (الناتج = `Math.pow(${يسار}, ${يمين})`)
                : (الناتج = Math.pow(يسار, يمين)); // قوة
            break;
        case "\\^":
            مع_متغير
                ? (الناتج = `Math.sqrt(${يمين})`)
                : (الناتج = Math.sqrt(يمين)); // جذر
            break;

        // الإسناد الرجعي
        case "+=":
            الناتج = `${يسار} += ${يمين}`;
            break;
        case "-=":
            الناتج = `${يسار} -= ${يمين}`;
            break;
        case "*=":
            الناتج = `${يسار} *= ${يمين}`;
            break;
        case "\\=":
            الناتج = `${يسار} /= ${يمين}`;
            break;
        case "^=":
            الناتج = `${يسار} = Math.pow(${يسار}, ${يمين})`;
            break;
        case "\\*=":
            الناتج = `${يسار} =  Math.floor(${يسار} / ${يمين})`;
            break;
        case "\\\\=":
            الناتج = `${يسار} %= ${يمين}`;
            break;

        // المقارنات
        case ">":
            مع_متغير ? (الناتج = `${يسار} > ${يمين}`) : (الناتج = يسار > يمين);
            break;
        case "<":
            مع_متغير ? (الناتج = `${يسار} < ${يمين}`) : (الناتج = يسار < يمين);
            break;
        case "=":
            مع_متغير ? (الناتج = `${يسار} = ${يمين}`) : (الناتج = يسار = يمين);
            break;
        case "==":
            مع_متغير
                ? (الناتج = `${يسار} == ${يمين}`)
                : (الناتج = يسار == يمين);
            break;
        case "!=":
            مع_متغير
                ? (الناتج = `${يسار} != ${يمين}`)
                : (الناتج = يسار != يمين);
            break;
        case ">=":
            مع_متغير
                ? (الناتج = `${يسار} >= ${يمين}`)
                : (الناتج = يسار >= يمين);
            break;
        case "<=":
            مع_متغير
                ? (الناتج = `${يسار} <= ${يمين}`)
                : (الناتج = يسار <= يمين);
            break;
        case "و":
            مع_متغير
                ? (الناتج = `${يسار} && ${يمين}`)
                : (الناتج = يسار && يمين);
            break;
        case "او":
        case "أو":
            مع_متغير
                ? (الناتج = `${يسار} || ${يمين}`)
                : (الناتج = يسار || يمين);
            break;
        case "ليس":
            مع_متغير ? (الناتج = `!${يسار}`) : (الناتج = !يسار);
            break;
        case "ليس في":
            الناتج = `(!${يمين}.includes(${يسار}))`;
            break;
        default:
            throw new Error("رمز حسابي غير معروف");
    }

    return مع_متغير ? الناتج : الناتج.toString();
}
