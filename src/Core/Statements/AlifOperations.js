import { احصل, التالي, السابق, تحقق, تطابق } from "../TokenUtils.js";
import { محلل_التعبير } from "../Expressions.js";
import { إنشاء_الشفرة } from "../../AlifGenerator.js";

// تحديد أولويات العمليات الحسابية
const أولويات_العمليات = {
    "+": 2,
    "-": 2,
    "*": 1,
    "\\": 1, // قسمة
    "\\\\": 2, // باقي القسمة
    "\\*": 3, // ناتج القسمة
    "^": 2, // قوة
    "\\^": 2, // جزر

    // المقارنات
    "<": 4,
    ">": 4,
    "==": 4,
    "!=": 4,
    "<=": 4,
    ">=": 4,
    و: 4,
    او: 4,
    ليس: 4,

    // الإسناد الرجعي
    "+=": 6,
    "-=": 6,
    "*=": 6,
    "\\=": 6,
    "^=": 6,
    "\\*=": 6,
    "\\\\=": 6,
};

export function محلل_العمليات(الرموز) {
    if (!الرموز || !Array.isArray(الرموز)) {
        throw new Error(
            'الرموز غير معرفة أو غير صحيحة "محلل_العمليات" ' + الرموز
        );
    }
    return محلل_التعبير_مع_الأولوية(الرموز, 0);
}

// دالة مساعدة لقراءة عامل واحد (رقم أو معرف أو تعبير بين قوسين)
function قراءة_عامل(الرموز) {
    while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد")) التالي(الرموز);

    let عامل;
    if (تطابق(الرموز, "اقواس", "(")) {
        عامل = محلل_التعبير_مع_الأولوية(الرموز, 0);
        if (!تطابق(الرموز, "اقواس", ")")) {
            const error = new Error(`لم يتم اغلاق القوس ")"`);
            error.line = `في السطر ` + احصل(الرموز).السطر;
            throw error;
        }
    } else if (تحقق(الرموز, "رمز_حسابي", "\\^")) {
        التالي(الرموز);
        عامل = محلل_التعبير_مع_الأولوية(الرموز, 0);
    } else if (تحقق(الرموز, "كلمة", "صحيح") || تحقق(الرموز, "كلمة", "عشري")) {
        عامل = محلل_التعبير(الرموز);
    } else {
        عامل = تطابق(الرموز, "رقم") || تطابق(الرموز, "معرف");
        if (!عامل) {
            const error = new Error("متوقع رقم أو معرف");
            error.line = `في السطر ` + احصل(الرموز).السطر;
            throw error;
        }

        // تحويل العامل إلى الصيغة المطلوبة
        عامل = {
            نوع: "عدد",
            قيمة: !isNaN(Number(عامل.القيمة))
                ? Number(عامل.القيمة)
                : عامل.القيمة
                ? عامل.القيمة
                : عامل,
        };
    }
    return عامل;
}

// دالة لتحليل التعبيرات مع مراعاة الأولوية
function محلل_التعبير_مع_الأولوية(الرموز, الاولوية) {
    let يسار = قراءة_عامل(الرموز);

    while (true) {
        // تخطي المسافات والأسطر الجديدة
        while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد"))
            التالي(الرموز);

        // تحقق من وجود عامل حسابي
        if (!تحقق(الرموز, "رمز_حسابي")) break;
        const عامل = تطابق(الرموز, "رمز_حسابي");
        if (!عامل || !("القيمة" in عامل)) break;

        // تحديد أولوية العامل الحالي
        const أولوية_العامل = أولويات_العمليات[عامل.القيمة] || 0;

        // إذا كانت أولوية العامل أقل من الأولوية المطلوبة، نتوقف
        if (أولوية_العامل <= الاولوية) {
            السابق(الرموز); // إرجاع العامل إلى مكانه لمعالجته في المستوى الأعلى
            break;
        }

        // قراءة العامل اليمين مع مراعاة الأولوية
        const يمين = محلل_التعبير_مع_الأولوية(الرموز, أولوية_العامل);

        // بناء عملية جديدة
        يسار = {
            نوع: "عملية",
            القيم: {
                يسار: يسار,
                عامل: { نوع: "رمز_حسابي", قيمة: عامل.القيمة },
                يمين: يمين,
            },
        };
    }

    return يسار;
}

export function منشئ_عمليات(عقدة, مستوى, عداد) {
    let يسار, يمين;
    let عامل = عقدة.القيم.عامل.قيمة;

    // التعامل مع الطرف الأيسر
    if (عقدة.القيم.يسار.نوع === "عملية") {
        يسار = منشئ_عمليات(عقدة.القيم.يسار, مستوى, عداد);
    } else if (
        عقدة.القيم.يسار.نوع === "صحيح" ||
        عقدة.القيم.يسار.نوع === "عشري"
    ) {
        يسار = إنشاء_الشفرة(عقدة.القيم.يسار, مستوى, عداد);
    } else {
        يسار = عقدة.القيم.يسار.قيمة;
    }

    // التعامل مع الطرف الأيمن
    if (عقدة.القيم.يمين.نوع === "عملية") {
        يمين = منشئ_عمليات(عقدة.القيم.يمين, مستوى, عداد);
    } else if (
        عقدة.القيم.يمين.نوع === "صحيح" ||
        عقدة.القيم.يمين.نوع === "عشري"
    ) {
        يمين = إنشاء_الشفرة(عقدة.القيم.يمين, مستوى, عداد);
    } else {
        يمين = عقدة.القيم.يمين.قيمة;
    }

    let الناتج = null;
    switch (عامل) {
        case "+":
            الناتج = `(${يسار} + ${يمين})`;
            break;
        case "-":
            الناتج = `(${يسار} - ${يمين})`;
            break;
        case "*":
            الناتج = `(${يسار} * ${يمين})`;
            break;
        case "\\":
            الناتج = `(${يسار} / ${يمين})`; // قسمة
            break;
        case "\\\\": // باقي القسمة
            الناتج = `(${يسار} % ${يمين})`;
            break;
        case "\\*": // ناتج القسمة
            الناتج = `Math.floor(${يسار} / ${يمين})`;
            break;
        case "^":
            الناتج = `Math.pow(${يسار}, ${يمين})`; // قوة
            break;
        case "\\^":
            الناتج = `Math.sqrt(${يمين})`; // جذر
            break;

        // الإسناد الرجعي
        case "+=":
            الناتج = `(${يسار} += ${يمين})`;
            break;
        case "-=":
            الناتج = `(${يسار} -= ${يمين})`;
            break;
        case "*=":
            الناتج = `(${يسار} *= ${يمين})`;
            break;
        case "\\=":
            الناتج = `(${يسار} /= ${يمين})`;
            break;
        case "^=":
            الناتج = `${يسار} = Math.pow(${يسار}, ${يمين})`;
            break;
        case "\\*=":
            الناتج = `${يسار} =  Math.floor(${يسار} / ${يمين})`;
            break;
        case "\\\\=":
            الناتج = `(${يسار} %= ${يمين})`;
            break;

        // المقارنات
        case ">":
            الناتج = `(${يسار} > ${يمين})`;
            break;
        case "<":
            الناتج = `(${يسار} < ${يمين})`;
            break;
        case "=":
            الناتج = `(${يسار} = ${يمين})`;
            break;
        case "==":
            الناتج = `(${يسار} == ${يمين})`;
            break;
        case "!=":
            الناتج = `(${يسار} != ${يمين})`;
            break;
        case ">=":
            الناتج = `(${يسار} >= ${يمين})`;
            break;
        case "<=":
            الناتج = `(${يسار} <= ${يمين})`;
            break;
        case "و":
            الناتج = `(${يسار} && ${يمين})`;
            break;
        case "او":
        case "أو":
            الناتج = `(${يسار} || ${يمين})`;
            break;
        case "ليس":
            الناتج = `(!${يسار})`;
            break;
        default:
            throw new Error("رمز حسابي غير معروف");
    }

    return الناتج.toString();
}
