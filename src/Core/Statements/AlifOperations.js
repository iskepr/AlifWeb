import { احصل, التالي, السابق, تحقق, تطابق } from "../TokenUtils.js";
import { محلل_التعبير } from "../Expressions.js";

// تحديد أولويات العمليات الحسابية
const أولويات_العمليات = {
    "+": 1,
    "-": 1,
    "*": 2,
    "\\": 2,
    "%": 2,
    "\\\\": 2,
    "^": 3,
    "\\^": 3,
    "\\*": 3,

    // المقارنات
    "<": 4,
    ">": 4,
    "==": 4,
    "!=": 4,
    "<=": 4,
    ">=": 4,
    و: 5,
    او: 5,
    ليس: 5,

    // الإسناد الرجعي
    "+=": 6,
    "-=": 6,
    "*=": 6,
    "\\=": 6,
    "^=": 6,
    "\\*=": 6,
    "\\\\=": 6,
};

export function محلل_العمليات(الرموز) {
    if (!الرموز || !Array.isArray(الرموز)) {
        throw new Error(
            'الرموز غير معرفة أو غير صحيحة "محلل_العمليات" ' + الرموز
        );
    }
    return محلل_التعبير_مع_الأولوية(الرموز, 0);
}

// دالة مساعدة لقراءة عامل واحد (رقم أو معرف أو تعبير بين قوسين)
function قراءة_عامل(الرموز) {
    while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد")) التالي(الرموز);

    let عامل;
    if (تطابق(الرموز, "اقواس", "(")) {
        عامل = محلل_التعبير_مع_الأولوية(الرموز, 0);
        if (!تطابق(الرموز, "اقواس", ")")) {
            const error = new Error(`لم يتم اغلاق القوس ")"`);
            error.line = `في السطر ` + احصل(الرموز).السطر;
            throw error;
        }
    } else if (تحقق(الرموز, "رمز_حسابي", "\\^")) {
        التالي(الرموز);
        عامل = محلل_التعبير_مع_الأولوية(الرموز, 0);
    } else if (تحقق(الرموز, "كلمة", "صحيح")) {
        عامل = محلل_التعبير(الرموز);
    } else {
        عامل = تطابق(الرموز, "رقم") || تطابق(الرموز, "معرف");
        if (!عامل) {
            const error = new Error("متوقع رقم أو معرف");
            error.line = `في السطر ` + احصل(الرموز).السطر;
            throw error;
        }

        // تحويل العامل إلى الصيغة المطلوبة
        عامل = {
            نوع: "عدد",
            قيمة: !isNaN(Number(عامل.القيمة))
                ? Number(عامل.القيمة)
                : عامل.القيمة
                ? عامل.القيمة
                : عامل,
        };
    }
    return عامل;
}

// دالة لتحليل التعبيرات مع مراعاة الأولوية
function محلل_التعبير_مع_الأولوية(الرموز, الاولوية) {
    let يسار = قراءة_عامل(الرموز);

    while (true) {
        // تخطي المسافات والأسطر الجديدة
        while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد"))
            التالي(الرموز);

        // تحقق من وجود عامل حسابي
        if (!تحقق(الرموز, "رمز_حسابي")) break;
        const عامل = تطابق(الرموز, "رمز_حسابي");
        if (!عامل || !("القيمة" in عامل)) break;

        // تحديد أولوية العامل الحالي
        const أولوية_العامل = أولويات_العمليات[عامل.القيمة] || 0;

        // إذا كانت أولوية العامل أقل من الأولوية المطلوبة، نتوقف
        if (أولوية_العامل <= الاولوية) {
            السابق(الرموز); // إرجاع العامل إلى مكانه لمعالجته في المستوى الأعلى
            break;
        }

        // قراءة العامل اليمين مع مراعاة الأولوية
        const يمين = محلل_التعبير_مع_الأولوية(الرموز, أولوية_العامل);

        // بناء عملية جديدة
        يسار = {
            نوع: "عملية",
            القيم: {
                يسار: يسار,
                عامل: { نوع: "رمز_حسابي", قيمة: عامل.القيمة },
                يمين: يمين,
            },
        };
    }

    return يسار;
}

export function منشئ_عمليات(عقدة) {
    let يسار, يمين;
    let عامل = عقدة.القيم.عامل.قيمة;

    // التعامل مع الطرف الأيسر
    if (عقدة.القيم.يسار.نوع === "عملية") {
        يسار = منشئ_عمليات(عقدة.القيم.يسار);
    } else {
        يسار = عقدة.القيم.يسار.قيمة;
    }

    // التعامل مع الطرف الأيمن
    if (عقدة.القيم.يمين.نوع === "عملية") {
        يمين = منشئ_عمليات(عقدة.القيم.يمين);
    } else {
        يمين = عقدة.القيم.يمين.قيمة;
    }

    let مع_متغير =
        typeof يسار == "number" && typeof يمين == "number" ? false : true;

    let الناتج = null;
    switch (عامل) {
        case "+":
            مع_متغير ? (الناتج = `${يسار} + ${يمين}`) : (الناتج = يسار + يمين);
            break;
        case "-":
            مع_متغير ? (الناتج = `${يسار} - ${يمين}`) : (الناتج = يسار - يمين);
            break;
        case "*":
            مع_متغير ? (الناتج = `${يسار} * ${يمين}`) : (الناتج = يسار * يمين);
            break;
        case "\\":
            مع_متغير ? (الناتج = `${يسار} / ${يمين}`) : (الناتج = يسار / يمين); // قسمة
            break;
        case "\\\\": // باقي القسمة
            مع_متغير ? (الناتج = `${يسار} % ${يمين}`) : (الناتج = يسار % يمين);
            break;
        case "\\*": // ناتج القسمة
            مع_متغير
                ? (الناتج = `Math.floor(${يسار} / ${يمين})`)
                : (الناتج = Math.floor(يسار / يمين));
            break;
        case "^":
            مع_متغير
                ? (الناتج = `Math.pow(${يسار}, ${يمين})`)
                : (الناتج = Math.pow(يسار, يمين)); // قوة
            break;
        case "\\^":
            مع_متغير
                ? (الناتج = `Math.sqrt(${يمين})`)
                : (الناتج = Math.sqrt(يمين)); // جذر
            break;

        // الإسناد الرجعي
        case "+=":
            الناتج = `${يسار} += ${يمين}`;
            break;
        case "-=":
            الناتج = `${يسار} -= ${يمين}`;
            break;
        case "*=":
            الناتج = `${يسار} *= ${يمين}`;
            break;
        case "\\=":
            الناتج = `${يسار} /= ${يمين}`;
            break;
        case "^=":
            الناتج = `${يسار} = Math.pow(${يسار}, ${يمين})`;
            break;
        case "\\*=":
            الناتج = `${يسار} =  Math.floor(${يسار} / ${يمين})`;
            break;
        case "\\\\=":
            الناتج = `${يسار} %= ${يمين}`;
            break;

        // المقارنات
        case ">":
            مع_متغير ? (الناتج = `${يسار} > ${يمين}`) : (الناتج = يسار > يمين);
            break;
        case "<":
            مع_متغير ? (الناتج = `${يسار} < ${يمين}`) : (الناتج = يسار < يمين);
            break;
        case "=":
            مع_متغير ? (الناتج = `${يسار} = ${يمين}`) : (الناتج = يسار = يمين);
            break;
        case "==":
            مع_متغير
                ? (الناتج = `${يسار} == ${يمين}`)
                : (الناتج = يسار == يمين);
            break;
        case "!=":
            مع_متغير
                ? (الناتج = `${يسار} != ${يمين}`)
                : (الناتج = يسار != يمين);
            break;
        case ">=":
            مع_متغير
                ? (الناتج = `${يسار} >= ${يمين}`)
                : (الناتج = يسار >= يمين);
            break;
        case "<=":
            مع_متغير
                ? (الناتج = `${يسار} <= ${يمين}`)
                : (الناتج = يسار <= يمين);
            break;
        case "و":
            مع_متغير
                ? (الناتج = `${يسار} && ${يمين}`)
                : (الناتج = يسار && يمين);
            break;
        case "او":
        case "أو":
            مع_متغير
                ? (الناتج = `${يسار} || ${يمين}`)
                : (الناتج = يسار || يمين);
            break;
        case "ليس":
            مع_متغير ? (الناتج = `!${يسار}`) : (الناتج = !يسار);
            break;
        default:
            throw new Error("رمز حسابي غير معروف");
    }

    return مع_متغير ? الناتج : الناتج.toString();
}
