import { إنشاء_الشفرة } from "../../AlifGenerator.js";
import { محلل_التعبير } from "../Expressions.js";
import { تحقق, تطابق, التالي } from "../TokenUtils.js";

export function محلل_الرياضيات(الرموز) {
    if (!الرموز || !Array.isArray(الرموز)) {
        throw new Error(
            'الرموز غير معرفة أو غير صحيحة "محلل_الرياضيات" ' + الرموز
        );
    }

    let الامر = null;

    تطابق(الرموز, "كلمة", "الرياضيات");
    تطابق(الرموز, "نقطة");

    const اوامر = [
        "جيب",
        "تجيب",
        "ظل",
        "مسافة",
        "قيمة_مطلقة",
        "المضروب",
        "قم_اكبر",
        "قم_اصغر",
        "حد_اعلى",
        "حد_ادنى",
        "لوغ",
        "راديان",
        "درجة",
    ];

    for (const امر_محتمل of اوامر) {
        if (تطابق(الرموز, "معرف", امر_محتمل)) {
            الامر = امر_محتمل;
            break;
        }
    }

    تطابق(الرموز, "اقواس", "(");

    let قيم = [];
    while (!تحقق(الرموز, "اقواس", ")")) {
        const قيمة = محلل_التعبير(الرموز);
        if (!قيمة) break;
        قيم.push(قيمة);

        // تخطي المسافات والاسطر الفارغة
        while (تحقق(الرموز, "مسافة") || تحقق(الرموز, "سطر_جديد"))
            التالي(الرموز);

        if (تحقق(الرموز, "فاصلة")) التالي(الرموز);
    }
    تطابق(الرموز, "اقواس", ")");

    return { نوع: "الرياضيات", الامر, قيم };
}

export function منشئ_الرياضيات(مستوى, عداد, عقدة) {
    const الامر = عقدة.الامر;
    const قيم = عقدة.قيم
        .map((v) => إنشاء_الشفرة(v, مستوى, عداد))
        .filter((v) => v !== "0");
    let قيمة = قيم.join(", ");

    const تحويلات = {
        جيب: (v) => `Math.sin(${v})`,
        تجيب: (v) => `Math.cos(${v})`,
        ظل: (v) => `Math.tan(${v})`,
        مسافة: (v) => `مسافة(${v})`,
        قيمة_مطلقة: (v) => `Math.abs(${v})`,
        المضروب: (v) => `المضروب(${v})`,
        قم_اكبر: (v) => `Math.max(${v})`,
        قم_اصغر: (v) => `Math.min(${v})`,
        حد_اعلى: (v) => `Math.ceil(${v})`,
        حد_ادنى: (v) => `Math.floor(${v})`,
        لوغ: (v) => `Math.log(${v})`,
        راديان: (v) => `${v} * Math.PI / 180`,
        درجة: (v) => `${v} * 180 / Math.PI`,
    };

    if (تحويلات[الامر]) return تحويلات[الامر](قيمة);
}
